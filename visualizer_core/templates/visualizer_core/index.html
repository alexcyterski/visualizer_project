<!DOCTYPE html>
<html>
<head>
    <title>Audio Spectrum Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .controls h2 {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-item {
            margin-bottom: 10px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
        }
        
        input[type="range"], select {
            width: 100%;
        }
        
        input[type="color"] {
            width: 50px;
            height: 30px;
            vertical-align: middle;
        }
        
        .color-preset {
            display: inline-block;
            width: 25px;
            height: 25px;
            margin: 0 5px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .color-preset.active {
            border-color: white;
        }
        
        button {
            padding: 10px 15px;
            font-size: 14px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        #toggleControls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 11;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            display: none;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            z-index: 10;
        }
        
        .control-item.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .control-item.disabled input {
            cursor: not-allowed;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .controls {
                width: 90%;
                max-width: 350px;
                right: 5%;
                left: 5%;
                margin: 0 auto;
                top: 10px;
                max-height: 80vh;
            }
            
            #toggleControls {
                display: block !important;
                top: 10px;
                right: 10px;
                z-index: 100;
            }
            
            button {
                padding: 12px 15px;
                margin-bottom: 15px;
                width: 100%;
                font-size: 16px;
            }
            
            .control-group {
                margin-bottom: 20px;
            }
            
            /* Make range sliders easier to use on mobile */
            input[type="range"] {
                height: 30px;
            }
            
            /* Adjust modal for mobile */
            .modal-content {
                width: 95%;
                margin: 5% auto;
                padding: 15px;
                max-height: 90vh;
            }
            
            /* iOS-specific fixes */
            .ios-device button {
                -webkit-appearance: none;
                border-radius: 8px;
            }
            
            .ios-device input[type="range"] {
                -webkit-appearance: none;
                height: 30px;
            }
            
            /* Hide controls by default on mobile */
            .mobile-device .controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="visualizer"></canvas>
    
    <div id="status">Click a button to start audio visualization</div>
    
    <button id="toggleControls">≡</button>
    
    <div class="controls" id="controlPanel">
        <h2>Audio Visualizer Controls</h2>
        
        <div class="control-group">
            <button id="startButton">Capture System Audio</button>
            <button id="micButton">Use Microphone</button>
            <button id="externalAudioButton">Connect to External Audio</button>
        </div>
        
        <div class="control-group">
            <h3>Visualization Style</h3>
            <div class="control-item">
                <label for="visualizationType">Type:</label>
                <select id="visualizationType">
                    <option value="bars">Bars</option>
                    <option value="wave">Waveform</option>
                    <option value="circular">Circular</option>
                </select>
            </div>
            <div class="control-item" id="mirroredModeControl">
                <label for="mirroredMode">Mirrored Mode:</label>
                <select id="mirroredMode">
                    <option value="mirrored">Mirrored (Center)</option>
                    <option value="top">From Top</option>
                    <option value="bottom" selected>From Bottom</option>
                </select>
            </div>
            <div class="control-item" id="autoScaleControl">
                <label>
                    <input type="checkbox" id="autoScale" checked>
                    Auto-scale bars to fill screen
                </label>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Color Settings</h3>
            <div class="control-item">
                <label for="colorMode">Color Mode:</label>
                <select id="colorMode">
                    <option value="gradient">Frequency Gradient</option>
                    <option value="solid">Solid Color</option>
                    <option value="rainbow">Rainbow</option>
                </select>
            </div>
            
            <div class="control-item" id="solidColorControl">
                <label for="barColor">Bar Color:</label>
                <input type="color" id="barColor" value="#00ffff">
            </div>
            
            <div class="control-item" id="gradientControls">
                <label>Gradient Colors:</label>
                <div>
                    <input type="color" id="gradientStart" value="#ff0000">
                    <span>to</span>
                    <input type="color" id="gradientEnd" value="#0000ff">
                </div>
            </div>
            
            <div class="control-item">
                <label>Color Presets:</label>
                <div>
                    <span class="color-preset" style="background: linear-gradient(to right, #ff0000, #0000ff);" data-start="#ff0000" data-end="#0000ff"></span>
                    <span class="color-preset" style="background: linear-gradient(to right, #00ff00, #ff00ff);" data-start="#00ff00" data-end="#ff00ff"></span>
                    <span class="color-preset" style="background: linear-gradient(to right, #ffff00, #00ffff);" data-start="#ffff00" data-end="#00ffff"></span>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Animation Settings</h3>
            <div class="control-item">
                <label for="sensitivity">Sensitivity: <span id="sensitivityValue">5</span></label>
                <input type="range" id="sensitivity" min="1" max="10" value="5">
            </div>
            
            <div class="control-item">
                <label for="smoothing">Smoothing: <span id="smoothingValue">0.8</span></label>
                <input type="range" id="smoothing" min="0" max="0.95" step="0.05" value="0.8">
            </div>
            
            <div class="control-item" id="barWidthControl">
                <label for="barWidth">Bar Width: <span id="barWidthValue">0.5</span></label>
                <input type="range" id="barWidth" min="0.1" max="1" step="0.1" value="0.5">
            </div>
            
            <div class="control-item" id="barSpacingControl">
                <label for="barSpacing">Bar Spacing: <span id="barSpacingValue">1</span></label>
                <input type="range" id="barSpacing" min="0" max="5" step="1" value="1">
            </div>
        </div>
        
        <div class="control-group">
            <h3>Frequency Settings</h3>
            <div class="control-item">
                <label for="frequencyScaling">Frequency Scaling:</label>
                <select id="frequencyScaling">
                    <option value="logarithmic">Logarithmic (Natural)</option>
                    <option value="linear">Linear</option>
                    <option value="exponential">Exponential (Emphasize Highs)</option>
                </select>
            </div>
            
            <div class="control-item">
                <label for="bassBoost">Bass Reduction: <span id="bassBoostValue">0</span></label>
                <input type="range" id="bassBoost" min="0" max="100" value="0">
            </div>
            
            <div class="control-item">
                <label for="highBoost">High Boost: <span id="highBoostValue">0</span></label>
                <input type="range" id="highBoost" min="0" max="100" value="0">
            </div>
            
            <div class="control-item">
                <label for="vocalEnhance">Vocal Enhancement: <span id="vocalEnhanceValue">0</span></label>
                <input type="range" id="vocalEnhance" min="0" max="100" value="0">
            </div>
            
            <div class="control-item">
                <label for="frequencySeparation">Frequency Separation: <span id="frequencySeparationValue">0</span></label>
                <input type="range" id="frequencySeparation" min="0" max="100" value="0">
            </div>
        </div>
        
        <div class="control-group">
            <h3>FFT Settings</h3>
            <div class="control-item">
                <label for="fftSize">FFT Size:</label>
                <select id="fftSize">
                    <option value="32">32</option>
                    <option value="64">64</option>
                    <option value="128">128</option>
                    <option value="256" selected>256</option>
                    <option value="512">512</option>
                    <option value="1024">1024</option>
                    <option value="2048">2048</option>
                </select>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Background Effects</h3>
            <div class="control-item">
                <label for="backgroundEffect">Background Type:</label>
                <select id="backgroundEffect">
                    <option value="none">None (Black)</option>
                    <option value="gradient">Color Gradient</option>
                    <option value="pulse">Pulse</option>
                    <option value="stars">Starfield</option>
                    <option value="noise">Noise</option>
                </select>
            </div>
            <div class="control-item" id="backgroundColorControls">
                <label>Background Colors:</label>
                <div>
                    <input type="color" id="bgColorStart" value="#000022">
                    <span>to</span>
                    <input type="color" id="bgColorEnd" value="#220022">
                </div>
            </div>
            <div class="control-item" id="backgroundIntensityControl">
                <label for="backgroundIntensity">Effect Intensity: <span id="backgroundIntensityValue">5</span></label>
                <input type="range" id="backgroundIntensity" min="1" max="10" value="5">
            </div>
        </div>
        
        <div class="control-group">
            <h3>Particle Effects</h3>
            <div class="control-item">
                <label for="particleEffect">Particle Type:</label>
                <select id="particleEffect">
                    <option value="none">None</option>
                    <option value="dots">Floating Dots</option>
                    <option value="lines">Connecting Lines</option>
                    <option value="bubbles">Bubbles</option>
                    <option value="sparkles">Sparkles</option>
                </select>
            </div>
            <div class="control-item">
                <label for="particleDensity">Particle Density: <span id="particleDensityValue">50</span></label>
                <input type="range" id="particleDensity" min="10" max="200" value="50">
            </div>
            <div class="control-item">
                <label for="particleSize">Particle Size: <span id="particleSizeValue">3</span></label>
                <input type="range" id="particleSize" min="1" max="10" value="3">
            </div>
            <div class="control-item">
                <label for="particleSpeed">Particle Speed: <span id="particleSpeedValue">2</span></label>
                <input type="range" id="particleSpeed" min="1" max="5" value="2">
            </div>
            <div class="control-item">
                <label for="particleColor">Particle Color:</label>
                <input type="color" id="particleColor" value="#ffffff">
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="particleReactToAudio" checked>
                    React to audio
                </label>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Beat Detection</h3>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="enableBeatDetection">
                    Enable beat detection
                </label>
            </div>
            <div class="control-item">
                <label for="beatSensitivity">Beat Sensitivity: <span id="beatSensitivityValue">1.5</span></label>
                <input type="range" id="beatSensitivity" min="1.1" max="2.0" step="0.1" value="1.5">
            </div>
            <div class="control-item">
                <label for="beatEffect">On Beat Effect:</label>
                <select id="beatEffect">
                    <option value="pulse">Screen Pulse</option>
                    <option value="flash">Flash</option>
                    <option value="zoom">Zoom</option>
                    <option value="shake">Shake</option>
                    <option value="color">Color Shift</option>
                </select>
            </div>
            <div class="control-item">
                <label for="beatEffectIntensity">Effect Intensity: <span id="beatEffectIntensityValue">5</span></label>
                <input type="range" id="beatEffectIntensity" min="1" max="10" value="5">
            </div>
        </div>
        
        <div class="control-group">
            <h3>Presets</h3>
            <div class="control-item preset-buttons">
                <button id="presetClassic">Classic</button>
                <button id="presetNeon">Neon</button>
                <button id="presetChill">Chill</button>
                <button id="presetParty">Party</button>
                <button id="presetSpace">Space</button>
            </div>
            <div class="control-item">
                <button id="savePreset">Save Current Settings</button>
                <button id="loadPreset">Load Custom Preset</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Display Options</h3>
            <div class="control-item">
                <button id="fullscreenButton">Toggle Fullscreen</button>
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="showFPS">
                    Show FPS
                </label>
            </div>
        </div>
        
    </div>

    <script>
        // Audio context setup
        let audioContext;
        let analyser;
        let source;
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        let width = canvas.width;
        let height = canvas.height;
        const statusElement = document.getElementById('status');
        
        // Visualization settings
        const settings = {
            visualizationType: 'bars',
            colorMode: 'gradient',
            barColor: '#00ffff',
            gradientStart: '#ff0000',
            gradientEnd: '#0000ff',
            sensitivity: 5,
            smoothing: 0.8,
            barWidth: 0.5,
            barSpacing: 1,
            fftSize: 256,
            frequencyScaling: 'logarithmic',
            bassBoost: 0,
            highBoost: 0,
            mirroredMode: 'mirrored',
            autoScale: true,
            vocalEnhance: 0,
            frequencySeparation: 0,
            // New settings for added features
            backgroundEffect: 'none',
            bgColorStart: '#000022',
            bgColorEnd: '#220022',
            backgroundIntensity: 5,
            particleEffect: 'none',
            particleDensity: 50,
            particleSize: 3,
            particleSpeed: 2,
            particleColor: '#ffffff',
            particleReactToAudio: true,
            enableBeatDetection: false,
            beatSensitivity: 1.5,
            beatEffect: 'pulse',
            beatEffectIntensity: 5,
            showFPS: false
        };
        
        // Beat detection variables
        let beatDetector = {
            energyHistory: [],
            historySize: 43, // About 1 second of history at 60fps
            beatCutoff: 0,
            beatCutoffDecay: 0.98,
            beatMinimum: 0.15,
            lastBeatTime: 0,
            debounceTime: 300, // Minimum time between beats in ms
            isBeat: false
        };
        
        // Particle system
        let particles = [];
        
        // Performance monitoring
        let lastFrameTime = 0;
        let fps = 0;
        
        // Initialize UI controls
        function initControls() {
            // Visualization type
            document.getElementById('visualizationType').addEventListener('change', function() {
                const type = this.value;
                settings.visualizationType = type;
                
                // Show/hide mirrored mode control based on visualization type
                const mirroredModeControl = document.getElementById('mirroredModeControl');
                if (type === 'circular') {
                    mirroredModeControl.classList.add('disabled');
                } else {
                    mirroredModeControl.classList.remove('disabled');
                }
                
                // Show/hide auto-scale control based on visualization type
                const autoScaleControl = document.getElementById('autoScaleControl');
                if (type === 'bars' || type === 'circular') {
                    autoScaleControl.style.display = 'block';
                } else {
                    autoScaleControl.style.display = 'none';
                }
                
                // Update auto-scale controls visibility
                updateAutoScaleControls();
                
                // Apply the visualization type change
                visualize();
            });
            
            // Color mode
            document.getElementById('colorMode').addEventListener('change', function() {
                settings.colorMode = this.value;
                updateColorControls();
            });
            
            // Bar color
            document.getElementById('barColor').addEventListener('input', function() {
                settings.barColor = this.value;
            });
            
            // Gradient colors
            document.getElementById('gradientStart').addEventListener('input', function() {
                settings.gradientStart = this.value;
            });
            
            document.getElementById('gradientEnd').addEventListener('input', function() {
                settings.gradientEnd = this.value;
            });
            
            // Color presets
            document.querySelectorAll('.color-preset').forEach(preset => {
                preset.addEventListener('click', function() {
                    document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                    this.classList.add('active');
                    settings.gradientStart = this.dataset.start;
                    settings.gradientEnd = this.dataset.end;
                    document.getElementById('gradientStart').value = settings.gradientStart;
                    document.getElementById('gradientEnd').value = settings.gradientEnd;
                });
            });
            
            // Sensitivity
            const sensitivitySlider = document.getElementById('sensitivity');
            const sensitivityValue = document.getElementById('sensitivityValue');
            sensitivitySlider.addEventListener('input', function() {
                settings.sensitivity = parseFloat(this.value);
                sensitivityValue.textContent = this.value;
            });
            
            // Smoothing
            const smoothingSlider = document.getElementById('smoothing');
            const smoothingValue = document.getElementById('smoothingValue');
            smoothingSlider.addEventListener('input', function() {
                settings.smoothing = parseFloat(this.value);
                smoothingValue.textContent = this.value;
                if (analyser) {
                    analyser.smoothingTimeConstant = settings.smoothing;
                }
            });
            
            // Bar width
            const barWidthSlider = document.getElementById('barWidth');
            const barWidthValue = document.getElementById('barWidthValue');
            barWidthSlider.addEventListener('input', function() {
                settings.barWidth = parseFloat(this.value);
                barWidthValue.textContent = this.value;
                visualize();
            });
            
            // Bar spacing
            const barSpacingSlider = document.getElementById('barSpacing');
            const barSpacingValue = document.getElementById('barSpacingValue');
            barSpacingSlider.addEventListener('input', function() {
                settings.barSpacing = parseInt(this.value);
                barSpacingValue.textContent = settings.barSpacing;
                visualize();
            });
            
            // FFT size
            document.getElementById('fftSize').addEventListener('change', function() {
                const newSize = parseInt(this.value);
                settings.fftSize = newSize;
                
                if (analyser) {
                    // Update the FFT size
                    analyser.fftSize = newSize;
                    
                    // Force a complete redraw and recalculation
                    resetVisualization();
                }
            });
            
            // Toggle controls visibility
            const toggleButton = document.getElementById('toggleControls');
            const controlPanel = document.getElementById('controlPanel');
            
            toggleButton.addEventListener('click', function() {
                if (controlPanel.style.display === 'none') {
                    controlPanel.style.display = 'block';
                    toggleButton.textContent = '×';
                } else {
                    controlPanel.style.display = 'none';
                    toggleButton.textContent = '≡';
                }
            });
            
            // Show toggle button on mobile or when controls are hidden
            toggleButton.style.display = 'block';
            
            // Update color controls based on selected mode
            updateColorControls();

            // Frequency scaling
            document.getElementById('frequencyScaling').addEventListener('change', function() {
                settings.frequencyScaling = this.value;
            });

            // Bass reduction
            const bassBoostSlider = document.getElementById('bassBoost');
            const bassBoostValue = document.getElementById('bassBoostValue');
            bassBoostSlider.addEventListener('input', function() {
                settings.bassBoost = parseInt(this.value);
                bassBoostValue.textContent = this.value;
            });

            // High boost
            const highBoostSlider = document.getElementById('highBoost');
            const highBoostValue = document.getElementById('highBoostValue');
            highBoostSlider.addEventListener('input', function() {
                settings.highBoost = parseInt(this.value);
                highBoostValue.textContent = this.value;
            });

            // Mirrored mode
            document.getElementById('mirroredMode').addEventListener('change', function() {
                settings.mirroredMode = this.value;
            });

            // Auto-scale option
            document.getElementById('autoScale').addEventListener('change', function() {
                settings.autoScale = this.checked;
                updateAutoScaleControls();
            });

            // Vocal enhancement
            const vocalEnhanceSlider = document.getElementById('vocalEnhance');
            const vocalEnhanceValue = document.getElementById('vocalEnhanceValue');
            vocalEnhanceSlider.addEventListener('input', function() {
                settings.vocalEnhance = parseInt(this.value);
                vocalEnhanceValue.textContent = this.value;
            });

            // Frequency separation
            const frequencySeparationSlider = document.getElementById('frequencySeparation');
            const frequencySeparationValue = document.getElementById('frequencySeparationValue');
            frequencySeparationSlider.addEventListener('input', function() {
                settings.frequencySeparation = parseInt(this.value);
                frequencySeparationValue.textContent = this.value;
            });
            
            // Background effect
            document.getElementById('backgroundEffect').addEventListener('change', function() {
                settings.backgroundEffect = this.value;
                updateBackgroundControls();
            });
            
            // Background colors
            document.getElementById('bgColorStart').addEventListener('input', function() {
                settings.bgColorStart = this.value;
            });
            
            document.getElementById('bgColorEnd').addEventListener('input', function() {
                settings.bgColorEnd = this.value;
            });
            
            // Background intensity
            const bgIntensitySlider = document.getElementById('backgroundIntensity');
            const bgIntensityValue = document.getElementById('backgroundIntensityValue');
            bgIntensitySlider.addEventListener('input', function() {
                settings.backgroundIntensity = parseInt(this.value);
                bgIntensityValue.textContent = this.value;
            });
            
            // Particle effect
            document.getElementById('particleEffect').addEventListener('change', function() {
                settings.particleEffect = this.value;
                updateParticleControls();
                
                // Initialize particles if needed
                if (settings.particleEffect !== 'none' && particles.length === 0) {
                    initParticles();
                }
            });
            
            // Particle density
            const particleDensitySlider = document.getElementById('particleDensity');
            const particleDensityValue = document.getElementById('particleDensityValue');
            particleDensitySlider.addEventListener('input', function() {
                settings.particleDensity = parseInt(this.value);
                particleDensityValue.textContent = this.value;
                
                // Reinitialize particles with new density
                if (settings.particleEffect !== 'none') {
                    initParticles();
                }
            });
            
            // Particle size
            const particleSizeSlider = document.getElementById('particleSize');
            const particleSizeValue = document.getElementById('particleSizeValue');
            particleSizeSlider.addEventListener('input', function() {
                settings.particleSize = parseInt(this.value);
                particleSizeValue.textContent = this.value;
            });
            
            // Particle speed
            const particleSpeedSlider = document.getElementById('particleSpeed');
            const particleSpeedValue = document.getElementById('particleSpeedValue');
            particleSpeedSlider.addEventListener('input', function() {
                settings.particleSpeed = parseInt(this.value);
                particleSpeedValue.textContent = this.value;
            });
            
            // Particle color
            document.getElementById('particleColor').addEventListener('input', function() {
                settings.particleColor = this.value;
            });
            
            // Particle react to audio
            document.getElementById('particleReactToAudio').addEventListener('change', function() {
                settings.particleReactToAudio = this.checked;
            });
            
            // Beat detection
            document.getElementById('enableBeatDetection').addEventListener('change', function() {
                settings.enableBeatDetection = this.checked;
                
                // Reset beat detector when enabled
                if (settings.enableBeatDetection) {
                    resetBeatDetector();
                }
            });
            
            // Beat sensitivity
            const beatSensitivitySlider = document.getElementById('beatSensitivity');
            const beatSensitivityValue = document.getElementById('beatSensitivityValue');
            beatSensitivitySlider.addEventListener('input', function() {
                settings.beatSensitivity = parseFloat(this.value);
                beatSensitivityValue.textContent = this.value;
            });
            
            // Beat effect
            document.getElementById('beatEffect').addEventListener('change', function() {
                settings.beatEffect = this.value;
            });
            
            // Beat effect intensity
            const beatEffectIntensitySlider = document.getElementById('beatEffectIntensity');
            const beatEffectIntensityValue = document.getElementById('beatEffectIntensityValue');
            beatEffectIntensitySlider.addEventListener('input', function() {
                settings.beatEffectIntensity = parseInt(this.value);
                beatEffectIntensityValue.textContent = this.value;
            });
            
            // Show FPS
            document.getElementById('showFPS').addEventListener('change', function() {
                settings.showFPS = this.checked;
            });
            
            // Fullscreen button
            document.getElementById('fullscreenButton').addEventListener('click', function() {
                toggleFullscreen();
            });
            
            // Preset buttons
            document.getElementById('presetClassic').addEventListener('click', function() {
                applyPreset('classic');
            });
            
            document.getElementById('presetNeon').addEventListener('click', function() {
                applyPreset('neon');
            });
            
            document.getElementById('presetChill').addEventListener('click', function() {
                applyPreset('chill');
            });
            
            document.getElementById('presetParty').addEventListener('click', function() {
                applyPreset('party');
            });
            
            document.getElementById('presetSpace').addEventListener('click', function() {
                applyPreset('space');
            });
            
            // Save preset
            document.getElementById('savePreset').addEventListener('click', function() {
                saveCurrentSettings();
            });
            
            // Load preset
            document.getElementById('loadPreset').addEventListener('click', function() {
                loadCustomPreset();
            });
            
            // Initialize background and particle controls
            updateBackgroundControls();
            updateParticleControls();
        }
        
        // Update background controls visibility based on selected effect
        function updateBackgroundControls() {
            const backgroundColorControls = document.getElementById('backgroundColorControls');
            const backgroundIntensityControl = document.getElementById('backgroundIntensityControl');
            
            if (settings.backgroundEffect === 'none') {
                backgroundColorControls.style.display = 'none';
                backgroundIntensityControl.style.display = 'none';
            } else if (settings.backgroundEffect === 'gradient') {
                backgroundColorControls.style.display = 'block';
                backgroundIntensityControl.style.display = 'none';
            } else {
                backgroundColorControls.style.display = 'block';
                backgroundIntensityControl.style.display = 'block';
            }
        }
        
        // Update particle controls visibility based on selected effect
        function updateParticleControls() {
            const particleControls = document.querySelectorAll('.control-group:nth-of-type(6) .control-item:not(:first-child)');
            
            if (settings.particleEffect === 'none') {
                particleControls.forEach(control => {
                    control.style.display = 'none';
                });
            } else {
                particleControls.forEach(control => {
                    control.style.display = 'block';
                });
            }
        }
        
        function updateColorControls() {
            const solidColorControl = document.getElementById('solidColorControl');
            const gradientControls = document.getElementById('gradientControls');
            
            if (settings.colorMode === 'solid') {
                solidColorControl.style.display = 'block';
                gradientControls.style.display = 'none';
            } else if (settings.colorMode === 'gradient') {
                solidColorControl.style.display = 'none';
                gradientControls.style.display = 'block';
            } else {
                solidColorControl.style.display = 'none';
                gradientControls.style.display = 'none';
            }
        }
        
        function updateVisualizationControls() {
            const mirroredModeControl = document.getElementById('mirroredModeControl');
            const autoScaleControl = document.getElementById('autoScaleControl');
            
            // Only show these controls for bar visualization
            if (settings.visualizationType === 'bars') {
                mirroredModeControl.style.display = 'block';
                autoScaleControl.style.display = 'block';
                updateAutoScaleControls();
            } else {
                mirroredModeControl.style.display = 'none';
                autoScaleControl.style.display = 'none';
            }
        }
        
        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    // iOS requires user interaction to start audio context
                    if (isIOS && audioContext.state === 'suspended') {
                        document.body.addEventListener('touchstart', function iosTouchStart() {
                            audioContext.resume().then(() => {
                                document.body.removeEventListener('touchstart', iosTouchStart);
                            });
                        }, false);
                    }
                } catch (e) {
                    console.error('Web Audio API is not supported in this browser', e);
                    document.getElementById('status').textContent = 'Error: Audio API not supported in your browser.';
                }
            }
        }

        // System audio capture button
        document.getElementById('startButton').addEventListener('click', async () => {
            try {
                initAudio();
                statusElement.textContent = "Requesting system audio access...";
                
                // Try to get display media with audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,  // Sometimes video needs to be true for audio to work
                    audio: true
                });
                
                // Check if we got audio tracks
                if (stream.getAudioTracks().length === 0) {
                    statusElement.textContent = "No audio track found. Make sure to check 'Share audio' in the dialog.";
                    return;
                }
                
                setupVisualization(stream);
            } catch (error) {
                statusElement.textContent = "Error: " + error.message;
                console.error("Setup error:", error);
            }
        });
        
        // Microphone fallback button
        document.getElementById('micButton').addEventListener('click', function() {
            document.getElementById('status').textContent = 'Requesting microphone access...';
            
            // For iOS, we need to ensure the audio context is created in response to a user gesture
            if (isIOS) {
                // Create audio context if it doesn't exist
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        // Force resume the audio context
                        audioContext.resume().then(() => {
                            console.log('AudioContext started on iOS');
                        }).catch(err => {
                            console.error('Failed to start AudioContext on iOS:', err);
                        });
                    } catch (e) {
                        console.error('Failed to create AudioContext on iOS:', e);
                    }
                } else if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Show a more visible permission prompt for iOS
                document.getElementById('status').innerHTML = '<strong>⚠️ Tap "Allow" when prompted for microphone access</strong>';
            }
            
            // Initialize audio context
            initAudio();
            
            // Use simpler constraints for iOS
            const constraints = isIOS ? {audio: true} : {
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            };
            
            // Add a slight delay for iOS to ensure the UI updates before permission prompt
            setTimeout(() => {
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function(stream) {
                        document.getElementById('status').textContent = 'Microphone connected!';
                        
                        // Disconnect any existing source
                        if (source) {
                            source.disconnect();
                        }
                        
                        // Connect the microphone to the audio context
                        source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        
                        // Start visualization
                        visualize();
                        
                        // Show the toggle controls button
                        document.getElementById('toggleControls').style.display = 'block';
                    })
                    .catch(function(err) {
                        console.error('Error accessing microphone:', err);
                        document.getElementById('status').innerHTML = '<strong>Error: ' + err.message + '</strong>';
                        
                        if (isIOS) {
                            showIOSHelpModal();
                        }
                    });
            }, isIOS ? 500 : 0);
        });
        
        // External audio button - revised to show instructions first
        document.getElementById('externalAudioButton').addEventListener('click', function() {
            if (isIOS) {
                // Show iOS-specific message
                const pages = [
                    {
                        title: "iOS External Audio",
                        content: `
                            <p>iOS doesn't support direct system audio capture. Instead:</p>
                            <ol>
                                <li>Use the microphone option</li>
                                <li>Place your device near the speakers</li>
                                <li>Adjust the volume for best results</li>
                            </ol>
                            
                            <div class="action-buttons">
                                <button id="use-mic-ios" style="background-color: #2196F3; padding: 12px 24px; font-size: 16px;">Use Microphone</button>
                            </div>
                        `
                    }
                ];
                
                const modal = createPaginatedModal("iOS Audio Capture", pages);
                
                setTimeout(() => {
                    const useMicBtn = modal.querySelector('#use-mic-ios');
                    if (useMicBtn) {
                        useMicBtn.addEventListener('click', function() {
                            document.body.removeChild(modal);
                            document.getElementById('micButton').click();
                        });
                    }
                }, 100);
            } else {
                // For non-iOS devices, show the regular external audio instructions
                document.getElementById('status').textContent = 'Preparing to connect to external audio...';
                showExternalAudioInstructionsWithStartButton();
            }
        });
        
        // Updated instructions modal with a start button
        function showExternalAudioInstructionsWithStartButton() {
            const pages = [
                {
                    title: "Basic Setup",
                    content: `
                        <p>To visualize audio from external applications like Spotify:</p>
                        <ol>
                            <li>On the next screen, select <strong>"Entire Screen"</strong> (not a specific window)</li>
                            <li>Make sure to check <strong>"Share audio"</strong> in the dialog box</li>
                            <li>Play audio in your application (Spotify, iTunes, etc.)</li>
                            <li>Return to this browser tab to see the visualization</li>
                        </ol>
                        
                        <p style="margin-top: 20px;">Select your operating system for specific setup instructions:</p>
                        <div class="os-buttons">
                            <button id="windows-setup-btn">Windows Setup</button>
                            <button id="mac-setup-btn">Mac Setup</button>
                            <button id="linux-setup-btn">Linux Setup</button>
                        </div>
                        
                        <div class="action-buttons">
                            <button id="startCaptureButton" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Start Audio Capture</button>
                        </div>
                    `
                },
                {
                    title: "Chrome/Edge Troubleshooting",
                    content: `
                        <p>If you don't see the "Share audio" option:</p>
                        <ol>
                            <li>First select "Chrome Tab" in the sharing dialog</li>
                            <li>Then click "Share" without selecting any tab</li>
                            <li>In the next dialog, select "Entire Screen" and check "Share audio"</li>
                        </ol>
                        <p>If you see "To share audio, use a tab instead":</p>
                        <ol>
                            <li>Try the above workaround</li>
                            <li>Make sure you're using the latest browser version</li>
                            <li>Some systems may require additional setup (see OS-specific pages)</li>
                        </ol>
                        
                        <div class="action-buttons">
                            <button id="startCaptureButton2" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Start Audio Capture</button>
                        </div>
                    `
                },
                {
                    title: "Windows Setup",
                    content: `
                        <h3>Enable Stereo Mix</h3>
                        <ol>
                            <li>Right-click the speaker icon in the taskbar</li>
                            <li>Select "Sounds" → "Recording" tab</li>
                            <li>Right-click in the empty area and check "Show Disabled Devices"</li>
                            <li>Right-click "Stereo Mix" and select "Enable"</li>
                            <li>Set it as the default device</li>
                        </ol>
                        
                        <h3>If Stereo Mix is not available</h3>
                        <ol>
                            <li>Update your audio drivers from your PC or sound card manufacturer</li>
                            <li>Use a virtual audio cable software:
                                <ul>
                                    <li><a href="https://vb-audio.com/Cable/" target="_blank">VB-Cable</a> (free)</li>
                                    <li><a href="https://www.voicemeeter.com/" target="_blank">Voicemeeter</a> (free)</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <div class="action-buttons">
                            <button id="startCaptureButton3" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Start Audio Capture</button>
                        </div>
                    `
                },
                {
                    title: "Mac Setup",
                    content: `
                        <p>macOS doesn't natively support system audio capture. You have two options:</p>
                        <ol>
                            <li>Use a virtual audio routing tool:
                                <ul>
                                    <li><a href="https://rogueamoeba.com/loopback/" target="_blank">Loopback</a> (paid)</li>
                                    <li><a href="https://existential.audio/blackhole/" target="_blank">BlackHole</a> (free)</li>
                                </ul>
                            </li>
                            <li>Install the <a href="https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk" target="_blank">Screen Capturing</a> extension for Chrome</li>
                        </ol>
                        <p>After setting up audio routing, select the virtual audio device as your system output.</p>
                        
                        <div class="action-buttons">
                            <button id="startCaptureButton4" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Start Audio Capture</button>
                        </div>
                    `
                },
                {
                    title: "Linux/Ubuntu Setup",
                    content: `
                        <h3>Comprehensive Audio Capture Setup for Linux</h3>
                        <ol>
                            <li>Install the necessary packages:
                                <code>sudo apt install pulseaudio pavucontrol alsa-utils</code>
                            </li>
                            <li>Open a terminal and load the ALSA loopback module:
                                <code>sudo modprobe snd-aloop</code>
                            </li>
                            <li>To make it load at boot (optional):
                                <code>echo "snd-aloop" | sudo tee -a /etc/modules</code>
                            </li>
                            <li>Open PulseAudio Volume Control:
                                <code>pavucontrol</code>
                            </li>
                            <li>Go to the "Playback" tab and ensure your audio application (e.g., Spotify) is playing audio.</li>
                            <li>Set the output of your audio application to "Loopback Analog Stereo".</li>
                            <li>Now click the "Start Audio Capture" button below.</li>
                            <li>In the "Recording" tab, set your browser to use "Monitor of Loopback Analog Stereo".</li>
                        </ol>
                        
                        <h3>Using Virtual Audio Devices</h3>
                        <ol>
                            <li>Create a virtual audio sink:
                                <code>pactl load-module module-null-sink sink_name=VirtualOutput sink_properties=device.description="Virtual Output"</code>
                            </li>
                            <li>Create a loopback to hear the audio:
                                <code>pactl load-module module-loopback source=VirtualOutput.monitor sink=@DEFAULT_SINK@</code>
                            </li>
                            <li>Open PulseAudio Volume Control:
                                <code>pavucontrol</code>
                            </li>
                            <li>Go to the "Playback" tab and set Spotify to output to "Virtual Output".</li>
                            <li>Click "Start Audio Capture" below.</li>
                            <li>In the "Recording" tab, set your browser to use "Monitor of Virtual Output".</li>
                        </ol>
                        
                        <h3>Using PipeWire (For Ubuntu 22.04+)</h3>
                        <ol>
                            <li>Install PipeWire:
                                <code>sudo apt install pipewire pipewire-pulse</code>
                            </li>
                            <li>Restart your system to apply changes.</li>
                            <li>Open PulseAudio Volume Control:
                                <code>pavucontrol</code>
                            </li>
                            <li>Go to the "Recording" tab and ensure your browser is set to record from "Monitor of Built-in Audio" or "Monitor of Virtual Output".</li>
                        </ol>
                        
                        <h3>Simple Microphone Method</h3>
                        <p>If all else fails, this simple method works on any system:</p>
                        <ol>
                            <li>Play your audio through speakers.</li>
                            <li>Click the "Use Microphone" button instead of "Start Audio Capture".</li>
                            <li>Position your microphone near the speakers.</li>
                            <li>Adjust volume levels to minimize distortion.</li>
                        </ol>
                        
                        <h3>One-Command Setup (Recommended)</h3>
                        <p>Copy and paste this entire command block into a terminal:</p>
                        <pre style="background-color: #333; padding: 10px; overflow-x: auto;">
#!/bin/bash
echo "Setting up virtual audio device for Ubuntu..."
SINK_ID=$(pactl load-module module-null-sink sink_name=VirtualOutput sink_properties=device.description="Virtual Output")
LOOPBACK_ID=$(pactl load-module module-loopback source=VirtualOutput.monitor sink=@DEFAULT_SINK@)
echo "Created virtual device (ID: $SINK_ID) and loopback (ID: $LOOPBACK_ID)"
echo "Now follow these steps:"
echo "1. Open pavucontrol (launching it for you)"
echo "2. Go to 'Playback' tab"
echo "3. Set Spotify to output to 'Virtual Output'"
echo "4. Click 'Start Audio Capture' in the browser"
echo "5. Go back to pavucontrol, 'Recording' tab"
echo "6. Set your browser to record from 'Monitor of Virtual Output'"
echo ""
echo "To remove these devices later, run:"
echo "pactl unload-module $SINK_ID"
echo "pactl unload-module $LOOPBACK_ID"
pavucontrol &
</pre>

                        <h3>If You Still Have Issues</h3>
                        <ul>
                            <li>Make sure PulseAudio is running: <code>pulseaudio --start</code></li>
                            <li>Try using Firefox instead of Chromium (often works better on Linux).</li>
                            <li>For Ubuntu 22.04+, try: <code>sudo apt install pipewire-pulse</code>.</li>
                            <li>Try installing the Chrome browser instead of Chromium.</li>
                            <li>As a last resort, use the microphone method described above.</li>
                        </ul>
                        
                        <div class="action-buttons">
                            <button id="startCaptureButton5" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Start Audio Capture</button>
                            <button id="useMicInstead" style="background-color: #2196F3; padding: 12px 24px; font-size: 16px;">Use Microphone Instead</button>
                        </div>
                    `
                }
            ];
            
            const modal = createPaginatedModal("Connect to External Audio Sources", pages);
            
            // Add event listeners for all start capture buttons
            setTimeout(() => {
                // Add listeners for all start capture buttons
                for (let i = 0; i <= 5; i++) {
                    const buttonId = i === 0 ? 'startCaptureButton' : `startCaptureButton${i}`;
                    const startButton = modal.querySelector(`#${buttonId}`);
                    if (startButton) {
                        startButton.addEventListener('click', function() {
                            document.body.removeChild(modal);
                            startExternalAudioCapture();
                        });
                    }
                }
                
                // Add listeners for OS setup buttons
                const windowsSetupBtn = modal.querySelector('#windows-setup-btn');
                const macSetupBtn = modal.querySelector('#mac-setup-btn');
                const linuxSetupBtn = modal.querySelector('#linux-setup-btn');
                
                if (windowsSetupBtn) {
                    windowsSetupBtn.addEventListener('click', function() {
                        // Go to Windows setup page (index 2)
                        showPage(2);
                    });
                }
                
                if (macSetupBtn) {
                    macSetupBtn.addEventListener('click', function() {
                        // Go to Mac setup page (index 3)
                        showPage(3);
                    });
                }
                
                if (linuxSetupBtn) {
                    linuxSetupBtn.addEventListener('click', function() {
                        // Go to Linux setup page (index 4)
                        showPage(4);
                    });
                }
                
                // Get the showPage function from the modal
                function showPage(pageNum) {
                    // Hide all pages
                    modal.querySelectorAll('.modal-page').forEach(page => {
                        page.classList.remove('active');
                    });
                    
                    // Show selected page
                    modal.querySelector(`.modal-page[data-page="${pageNum}"]`).classList.add('active');
                    
                    // Update pagination dots
                    modal.querySelectorAll('.page-dot').forEach(dot => {
                        dot.classList.remove('active');
                    });
                    modal.querySelector(`.page-dot[data-page="${pageNum}"]`).classList.add('active');
                }
            }, 100);
        }

        // Function to actually start the external audio capture
        function startExternalAudioCapture() {
            // Update status
            document.getElementById('status').textContent = 'Connecting to external audio...';
            
            // Initialize audio context if needed
            initAudio();
            
            // Start system audio capture with explicit audio option
            navigator.mediaDevices.getDisplayMedia({ 
                video: {
                    cursor: "always",
                    displaySurface: "monitor" // Specifically request the entire screen
                }, 
                audio: {
                    // Disable processing to get raw audio
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            })
            .then(function(stream) {
                // Check if the stream has audio tracks
                if (stream.getAudioTracks().length === 0) {
                    throw new Error('No audio track found. Make sure you selected "Share system audio" in the dialog.');
                }
                
                // Update status
                document.getElementById('status').textContent = 'External audio connected!';
                
                // Disconnect any existing source
                if (source) {
                    source.disconnect();
                }
                
                // Connect the stream to the audio context
                source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                // Start visualization
                visualize();
                
                // Show the toggle controls button
                document.getElementById('toggleControls').style.display = 'block';
            })
            .catch(function(err) {
                console.error('Error capturing system audio: ' + err);
                document.getElementById('status').textContent = 'Error: ' + err.message + '. See troubleshooting for help.';
                
                // Show troubleshooting modal
                showTroubleshootingModal();
            });
        }

        // Setup visualization with the provided stream
        function setupVisualization(stream) {
            // Disconnect any existing source
            if (source) {
                source.disconnect();
            }
            
            // Create a source node from the stream
            source = audioContext.createMediaStreamSource(stream);
            
            // Connect source to analyzer
            source.connect(analyser);
            
            statusElement.textContent = "Audio connected. Visualizing...";
            
            // Start the visualization
            visualize();
            
            // Log audio tracks for debugging
            console.log("Audio tracks:", stream.getAudioTracks().map(track => ({
                label: track.label,
                enabled: track.enabled,
                muted: track.muted,
                readyState: track.readyState
            })));
        }

        // Visualization function
        function visualize() {
            // Get the appropriate buffer length based on the current FFT size
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);
                
                // Get frequency data
                analyser.getByteFrequencyData(dataArray);
                
                // Clear the ENTIRE canvas/viewport each frame
                // This ensures no leftover bars from previous frames
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                ctx.fillStyle = 'rgb(0, 0, 0)';
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
                
                // Choose visualization type
                switch(settings.visualizationType) {
                    case 'bars':
                        drawBars(dataArray, bufferLength);
                        break;
                    case 'wave':
                        drawWave(dataArray, bufferLength);
                        break;
                    case 'circular':
                        drawCircular(dataArray, bufferLength);
                        break;
                    default:
                        drawBars(dataArray, bufferLength);
                }
            }
            
            draw();
        }
        
        // Draw bar visualization
        function drawBars(dataArray, bufferLength) {
            // Draw background effects first
            drawBackgroundEffects(dataArray);
            
            // Get the full viewport width
            const fullViewportWidth = window.innerWidth;
            
            // Determine how many frequency bins we have
            const frequencyBinCount = bufferLength;
            
            // Determine how many bars to display
            let visibleBarCount;
            
            if (settings.autoScale) {
                // For very large FFT sizes, limit the number of bars to keep them visible
                if (frequencyBinCount > 1024) {
                    visibleBarCount = 512; // Cap at a reasonable number
                } else if (frequencyBinCount > 512) {
                    visibleBarCount = 256;
                } else {
                    visibleBarCount = frequencyBinCount;
                }
            } else {
                visibleBarCount = frequencyBinCount;
            }
            
            // Calculate bar dimensions
            let barWidth, barSpacing;
            
            if (settings.autoScale) {
                // Calculate spacing as a percentage of the viewport width
                const spacingRatio = settings.barSpacing / 20; // Smaller ratio for better scaling
                
                // Calculate total width available for bars and spacing
                const totalSpacingWidth = fullViewportWidth * spacingRatio;
                const totalBarWidth = fullViewportWidth - totalSpacingWidth;
                
                // Calculate individual bar width and spacing
                if (visibleBarCount > 1) {
                    barWidth = totalBarWidth / visibleBarCount;
                    barSpacing = totalSpacingWidth / (visibleBarCount - 1);
                } else {
                    barWidth = totalBarWidth;
                    barSpacing = 0;
                }
            } else {
                // Use the user-defined settings
                // Calculate bar width based on the total width and number of bars
                const totalWidth = fullViewportWidth;
                // Convert barWidth from 0.1-1 range to a proportion of available space
                barWidth = (totalWidth / visibleBarCount) * settings.barWidth;
                // Use the barSpacing setting directly as pixels between bars
                barSpacing = settings.barSpacing;
            }
            
            // Calculate the vertical center of the screen
            const centerY = height / 2;
            
            // Start drawing from the left edge of the viewport
            let x = 0;
            
            // Calculate the step size if we're not showing all bars
            const step = Math.ceil(frequencyBinCount / visibleBarCount);
            
            // Draw each bar
            for (let i = 0; i < visibleBarCount; i++) {
                // Calculate the actual data index based on step size
                const dataIndex = Math.min(i * step, frequencyBinCount - 1);
                
                // Apply frequency scaling to the index
                let index;
                const normalizedI = i / visibleBarCount;
                
                if (settings.frequencyScaling === 'logarithmic') {
                    // Logarithmic scaling (more space for lower frequencies)
                    index = Math.floor(Math.pow(normalizedI, 0.5) * frequencyBinCount);
                } else if (settings.frequencyScaling === 'exponential') {
                    // Exponential scaling (more space for higher frequencies)
                    index = Math.floor(Math.pow(normalizedI, 2) * frequencyBinCount);
                } else {
                    // Linear scaling (equal space for all frequencies)
                    index = dataIndex;
                }
                
                // Ensure index is within bounds
                index = Math.min(index, frequencyBinCount - 1);
                
                // Get the value and apply frequency-specific adjustments
                let value = dataArray[index];
                
                // Apply bass reduction (for lower third of the spectrum)
                if (i < visibleBarCount / 3) {
                    value = Math.max(0, value - (settings.bassBoost / 100) * 255);
                }
                
                // Apply high boost (for upper third of the spectrum)
                if (i > (visibleBarCount * 2) / 3) {
                    value = Math.min(255, value + (settings.highBoost / 100) * 255);
                }
                
                // Apply vocal enhancement
                const vocalRangeStart = Math.floor(visibleBarCount * 0.1);
                const vocalRangeEnd = Math.floor(visibleBarCount * 0.3);
                
                if (i >= vocalRangeStart && i <= vocalRangeEnd) {
                    value = Math.min(255, value + (settings.vocalEnhance / 100) * 255);
                }
                
                // Apply frequency separation
                if (settings.frequencySeparation > 0) {
                    if (i % 2 === 0) {
                        value = Math.min(255, value * (1 + settings.frequencySeparation / 200));
                    } else {
                        value = Math.max(0, value * (1 - settings.frequencySeparation / 200));
                    }
                }
                
                // Set color based on color mode
                if (settings.colorMode === 'solid') {
                    ctx.fillStyle = settings.barColor;
                } else if (settings.colorMode === 'gradient') {
                    const ratio = i / visibleBarCount;
                    const r1 = parseInt(settings.gradientStart.slice(1, 3), 16);
                    const g1 = parseInt(settings.gradientStart.slice(3, 5), 16);
                    const b1 = parseInt(settings.gradientStart.slice(5, 7), 16);
                    const r2 = parseInt(settings.gradientEnd.slice(1, 3), 16);
                    const g2 = parseInt(settings.gradientEnd.slice(3, 5), 16);
                    const b2 = parseInt(settings.gradientEnd.slice(5, 7), 16);
                    
                    const r = Math.floor(r1 + (r2 - r1) * ratio);
                    const g = Math.floor(g1 + (g2 - g1) * ratio);
                    const b = Math.floor(b1 + (b2 - b1) * ratio);
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                } else if (settings.colorMode === 'rainbow') {
                    const hue = (i / visibleBarCount * 360) % 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                }
                
                // Apply sensitivity and calculate bar height
                const barHeight = value * (settings.sensitivity / 5);
                
                // Draw based on the selected mode
                if (settings.mirroredMode === 'mirrored') {
                    // Mirrored mode (center)
                    const halfBarHeight = barHeight / 2;
                    ctx.fillRect(x, centerY - halfBarHeight, barWidth, halfBarHeight);
                    ctx.fillRect(x, centerY, barWidth, halfBarHeight);
                } else if (settings.mirroredMode === 'top') {
                    // From top
                    ctx.fillRect(x, 0, barWidth, barHeight);
                } else {
                    // From bottom (default)
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                }
                
                // Move to next bar position
                x += barWidth + barSpacing;
                
                // If we've gone beyond the viewport width, we can stop drawing
                if (x > fullViewportWidth) break;
            }
        }
        
        // Draw waveform visualization
        function drawWave(dataArray, bufferLength) {
            // Draw background effects first
            drawBackgroundEffects(dataArray);
            
            analyser.getByteTimeDomainData(dataArray);
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = settings.colorMode === 'solid' ? settings.barColor : settings.gradientStart;
            
            ctx.beginPath();
            
            const sliceWidth = width / bufferLength;
            let x = 0;
            
                for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }
        
        // Draw circular visualization
        function drawCircular(dataArray, bufferLength) {
            // Draw background effects first
            drawBackgroundEffects(dataArray);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 4;
            
            // Determine how many bars to display based on buffer length
            let visibleBarCount;
            
            if (settings.autoScale) {
                // For very large FFT sizes, limit the number of bars to keep them visible
                if (bufferLength > 1024) {
                    visibleBarCount = 512;
                } else if (bufferLength > 512) {
                    visibleBarCount = 256;
                } else {
                    visibleBarCount = bufferLength;
                }
            } else {
                visibleBarCount = bufferLength;
            }
            
            // Calculate the angle step based on visible bar count and spacing
            // Apply spacing by reducing the total angle covered
            const spacingFactor = 1 - (settings.barSpacing / 10); // Convert 0-5 range to a percentage
            const totalAngle = 2 * Math.PI * spacingFactor;
            const angleStep = totalAngle / visibleBarCount;
            
            // Calculate the bar width as a percentage of the angle step
            const barAngleWidth = angleStep * settings.barWidth;
            
            // Calculate the step size if we're not showing all bars
            const step = Math.ceil(bufferLength / visibleBarCount);
            
            for (let i = 0; i < visibleBarCount; i++) {
                // Calculate the actual data index based on step size
                const dataIndex = Math.min(i * step, bufferLength - 1);
                
                // Apply frequency scaling to the index
                let index;
                const normalizedI = i / visibleBarCount;
                
                if (settings.frequencyScaling === 'logarithmic') {
                    // Logarithmic scaling (more space for lower frequencies)
                    index = Math.floor(Math.pow(normalizedI, 0.5) * bufferLength);
                } else if (settings.frequencyScaling === 'exponential') {
                    // Exponential scaling (more space for higher frequencies)
                    index = Math.floor(Math.pow(normalizedI, 2) * bufferLength);
                } else {
                    // Linear scaling (equal space for all frequencies)
                    index = dataIndex;
                }
                
                // Ensure index is within bounds
                index = Math.min(index, bufferLength - 1);
                
                // Get the value and apply frequency-specific adjustments
                let value = dataArray[index];
                
                // Apply bass reduction (for lower third of the spectrum)
                if (i < visibleBarCount / 3) {
                    value = Math.max(0, value - (settings.bassBoost / 100) * 255);
                }
                
                // Apply high boost (for upper third of the spectrum)
                if (i > (visibleBarCount * 2) / 3) {
                    value = Math.min(255, value + (settings.highBoost / 100) * 255);
                }
                
                // Apply vocal enhancement (for mid-range frequencies where vocals typically sit)
                const vocalRangeStart = Math.floor(visibleBarCount * 0.1);
                const vocalRangeEnd = Math.floor(visibleBarCount * 0.3);

                if (i >= vocalRangeStart && i <= vocalRangeEnd) {
                    // Enhance the vocal range
                    value = Math.min(255, value + (settings.vocalEnhance / 100) * 255);
                }
                
                // Apply frequency separation to make individual frequencies more distinct
                if (settings.frequencySeparation > 0) {
                    // Create a "comb" effect by enhancing every other frequency
                    if (i % 2 === 0) {
                        value = Math.min(255, value * (1 + settings.frequencySeparation / 200));
                    } else {
                        value = Math.max(0, value * (1 - settings.frequencySeparation / 200));
                    }
                }
                
                // Apply sensitivity
                const barHeight = (value * (settings.sensitivity / 5)) / 256 * radius;
                
                // Calculate angle
                const angle = i * angleStep;
                
                // Set color based on color mode
                if (settings.colorMode === 'solid') {
                    ctx.strokeStyle = settings.barColor;
                } else if (settings.colorMode === 'gradient') {
                    const ratio = i / visibleBarCount;
                    const r1 = parseInt(settings.gradientStart.slice(1, 3), 16);
                    const g1 = parseInt(settings.gradientStart.slice(3, 5), 16);
                    const b1 = parseInt(settings.gradientStart.slice(5, 7), 16);
                    const r2 = parseInt(settings.gradientEnd.slice(1, 3), 16);
                    const g2 = parseInt(settings.gradientEnd.slice(3, 5), 16);
                    const b2 = parseInt(settings.gradientEnd.slice(5, 7), 16);
                    
                    const r = Math.floor(r1 + (r2 - r1) * ratio);
                    const g = Math.floor(g1 + (g2 - g1) * ratio);
                    const b = Math.floor(b1 + (b2 - b1) * ratio);
                    
                    ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                } else if (settings.colorMode === 'rainbow') {
                    const hue = (i / visibleBarCount * 360) % 360;
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                }
                
                // Apply bar width setting to line width
                ctx.lineWidth = Math.max(1, 5 * settings.barWidth);
                
                // Draw line
                ctx.beginPath();
                
                // Use the bar angle width to draw an arc instead of a line for thicker bars
                if (settings.barWidth > 0.3) {
                    const halfBarAngle = barAngleWidth / 2;
                    const startAngle = angle - halfBarAngle;
                    const endAngle = angle + halfBarAngle;
                    
                    // Draw inner arc
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    
                    // Draw outer arc (if there's a value)
                    if (barHeight > 0) {
                        ctx.arc(centerX, centerY, radius + barHeight, endAngle, startAngle, true);
                    }
                    
                    // Close the path
                    ctx.closePath();
                    ctx.fillStyle = ctx.strokeStyle;
                    ctx.fill();
                } else {
                    // For thin bars, just draw lines
                    const startX = centerX + Math.cos(angle) * radius;
                    const startY = centerY + Math.sin(angle) * radius;
                    const endX = centerX + Math.cos(angle) * (radius + barHeight);
                    const endY = centerY + Math.sin(angle) * (radius + barHeight);
                    
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
        }

        // Resize canvas when window resizes
        window.addEventListener('resize', () => {
            // Update canvas dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            
            // Reset the visualization to ensure proper scaling
            resetVisualization();
        });
        
        // Ensure the canvas is properly sized on initialization
        function initCanvas() {
            // Set canvas dimensions to match the viewport exactly
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            width = canvas.width;
            height = canvas.height;
            
            // Force the canvas to take up the full viewport
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '1';
        }

        // Add this function to toggle the animation controls based on auto-scale setting
        function updateAutoScaleControls() {
            const autoScale = document.getElementById('autoScale').checked;
            const visualizationType = document.getElementById('visualizationType').value;
            
            // Bar width control should be available for both bars and circular visualizations
            const barWidthControl = document.getElementById('barWidthControl');
            const barSpacingControl = document.getElementById('barSpacingControl');
            
            // Show/hide auto-scale control based on visualization type
            const autoScaleControl = document.getElementById('autoScaleControl');
            if (visualizationType === 'bars' || visualizationType === 'circular') {
                autoScaleControl.style.display = 'block';
                
                // Bar width and spacing should only be disabled when auto-scale is on
                const shouldDisable = autoScale;
                
                // Update the bar width control
                barWidthControl.classList.toggle('disabled', shouldDisable);
                document.getElementById('barWidth').disabled = shouldDisable;
                
                // Update the bar spacing control
                barSpacingControl.classList.toggle('disabled', shouldDisable);
                document.getElementById('barSpacing').disabled = shouldDisable;
            } else {
                autoScaleControl.style.display = 'none';
                
                // For wave visualization, always disable bar controls
                barWidthControl.classList.add('disabled');
                document.getElementById('barWidth').disabled = true;
                barSpacingControl.classList.add('disabled');
                document.getElementById('barSpacing').disabled = true;
            }
        }

        // Add a function to reset the visualization when needed
        function resetVisualization() {
            // Clear the entire canvas
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            ctx.fillStyle = 'rgb(0, 0, 0)';
            ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            
            // If we have an active audio source, restart the visualization
            if (source) {
                // Update analyzer settings
                analyser.fftSize = settings.fftSize;
                analyser.smoothingTimeConstant = settings.smoothing;
                
                // Restart visualization
                visualize();
            }
        }

        // Add modal styles to the head
        const modalStyles = document.createElement('style');
        modalStyles.textContent = `
            .modal {
                display: block;
                position: fixed;
                z-index: 100;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.7);
            }
            .modal-content {
                background-color: #222;
                color: white;
                margin: 10% auto;
                padding: 25px;
                border: 1px solid #444;
                border-radius: 8px;
                width: 80%;
                max-width: 700px;
                max-height: 80vh;
                /* Fixed height for consistent layout */
                height: 500px;
                display: flex;
                flex-direction: column;
            }
            .modal-header {
                margin-bottom: 15px;
            }
            .modal-pages {
                flex: 1;
                overflow-y: auto;
                /* Add padding to ensure content doesn't touch the pagination dots */
                padding-bottom: 15px;
                /* Fixed height to ensure consistent scrolling area */
                height: 350px;
                position: relative;
            }
            .close {
                color: #aaa;
                float: right;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
            }
            .close:hover {
                color: white;
            }
            .modal-footer {
                /* Fixed height footer */
                height: 60px;
                padding-top: 15px;
                margin-top: 15px;
                border-top: 1px solid #444;
                display: flex;
                justify-content: space-between;
                align-items: center;
                position: relative;
            }
            .modal-footer-buttons {
                display: flex;
                justify-content: flex-end;
                width: 100%;
            }
            .modal-footer button {
                padding: 8px 16px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                margin-left: 10px;
            }
            .modal-footer button.secondary {
                background-color: #555;
            }
            .modal-pagination {
                display: flex;
                justify-content: center;
                /* Add more space between pagination and content */
                margin: 20px 0;
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
            }
            .modal-pagination .page-dot {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                background-color: #555;
                margin: 0 5px;
                cursor: pointer;
            }
            .modal-pagination .page-dot.active {
                background-color: #4CAF50;
            }
            .modal-page {
                display: none;
            }
            .modal-page.active {
                display: block;
            }
            .modal h3 {
                margin-top: 15px;
                margin-bottom: 10px;
                color: #4CAF50;
            }
            .modal ul, .modal ol {
                margin-left: 20px;
                margin-bottom: 15px;
            }
            .modal li {
                margin-bottom: 8px;
            }
            .modal-page-title {
                text-align: center;
                margin-bottom: 20px;
                color: #4CAF50;
            }
            .action-buttons {
                margin-top: 20px;
                text-align: center;
            }
            .action-buttons button {
                padding: 10px 20px;
                margin: 0 10px;
            }
            .os-buttons {
                display: flex;
                justify-content: space-around;
                margin: 20px 0;
            }
            .os-buttons button {
                padding: 10px 15px;
                background-color: #555;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            /* Fixed position for navigation buttons */
            .nav-buttons {
                position: absolute;
                bottom: 15px;
                right: 25px;
                display: flex;
            }
            .left-buttons {
                position: absolute;
                bottom: 15px;
                left: 25px;
                display: flex;
            }
        `;
        document.head.appendChild(modalStyles);

        // Create a reusable modal system
        function createPaginatedModal(title, pages) {
            // Create modal element
            const modal = document.createElement('div');
            modal.className = 'modal';
            
            // Create modal content
            let modalContent = `
                <div class="modal-content">
                    <div class="modal-header">
                        <span class="close">&times;</span>
                        <h2>${title}</h2>
                    </div>
                    
                    <div class="modal-pages">
            `;
            
            // Add each page
            pages.forEach((page, index) => {
                modalContent += `
                    <div class="modal-page ${index === 0 ? 'active' : ''}" data-page="${index}">
                        <h3 class="modal-page-title">${page.title}</h3>
                        ${page.content}
                    </div>
                `;
            });
            
            // Add pagination dots
            modalContent += `
                    </div>
                    
                    <div class="modal-pagination">
            `;
            
            pages.forEach((_, index) => {
                modalContent += `
                    <div class="page-dot ${index === 0 ? 'active' : ''}" data-page="${index}"></div>
                `;
            });
            
            modalContent += `
                    </div>
                </div>
                
                <div class="modal-footer">
                    <div class="left-buttons">
                        <!-- Action buttons will be added here dynamically -->
                    </div>
                    <div class="nav-buttons">
                        <button class="prev-button secondary" ${pages.length > 1 ? '' : 'style="display:none"'}>Previous</button>
                        <button class="next-button" ${pages.length > 1 ? '' : 'style="display:none"'}>Next</button>
                    </div>
                </div>
            </div>
        `;
        
        // Add modal to body
        modal.innerHTML = modalContent;
        document.body.appendChild(modal);
        
        // Add event listeners
        const closeBtn = modal.querySelector('.close');
        const prevBtn = modal.querySelector('.prev-button');
        const nextBtn = modal.querySelector('.next-button');
        const pageDots = modal.querySelectorAll('.page-dot');
        
        closeBtn.addEventListener('click', function() {
            document.body.removeChild(modal);
        });
        
        // Function to show a specific page
        function showPage(pageNum) {
            const pages = modal.querySelectorAll('.modal-page');
            
            // Hide all pages
            pages.forEach(page => {
                page.classList.remove('active');
            });
            
            // Show selected page
            pages[pageNum].classList.add('active');
            
            // Update pagination dots
            pageDots.forEach(dot => {
                dot.classList.remove('active');
            });
            pageDots[pageNum].classList.add('active');
            
            // Update button states
            prevBtn.disabled = pageNum === 0;
            nextBtn.disabled = pageNum === pages.length - 1;
            
            // Change button appearance based on state
            if (pageNum === 0) {
                prevBtn.style.opacity = '0.5';
            } else {
                prevBtn.style.opacity = '1';
            }
            
            if (pageNum === pages.length - 1) {
                nextBtn.style.opacity = '0.5';
            } else {
                nextBtn.style.opacity = '1';
            }
        }
        
        // Add navigation event listeners
        let currentPage = 0;
        
        prevBtn.addEventListener('click', function() {
            if (currentPage > 0) {
                currentPage--;
                showPage(currentPage);
            }
        });
        
        nextBtn.addEventListener('click', function() {
            if (currentPage < pages.length - 1) {
                currentPage++;
                showPage(currentPage);
            }
        });
        
        // Add pagination dot event listeners
        pageDots.forEach((dot, index) => {
            dot.addEventListener('click', function() {
                currentPage = index;
                showPage(currentPage);
            });
        });
        
        // Make the modal object available
        return modal;
    }

    // Add device detection function
    function detectMobileDevice() {
        const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.body.classList.add('mobile-device');
            document.getElementById('toggleControls').style.display = 'block';
        }
        
        if (isIOS) {
            document.body.classList.add('ios-device');
            // Show iOS-specific instructions
            document.getElementById('status').textContent = 'Tap a button to start. iOS requires microphone access.';
        }
        
        return { isMobile, isIOS };
    }

    // Call device detection on page load
    const { isMobile, isIOS } = detectMobileDevice();

    // Add iOS-specific help modal
    function showIOSHelpModal() {
        const pages = [
            {
                title: "iOS Audio Setup",
                content: `
                    <p>On iOS devices, you'll need to:</p>
                    <ol>
                        <li>Allow microphone access when prompted</li>
                        <li>Use the microphone option for best results</li>
                        <li>Make sure your device is not on silent mode</li>
                        <li>For external audio, place the microphone near your speakers</li>
                    </ol>
                    <p>Note: iOS has limitations on audio capture. The microphone method works best.</p>
                    
                    <div class="action-buttons">
                        <button id="try-mic-again" style="background-color: #4CAF50; padding: 12px 24px; font-size: 16px;">Try Microphone Again</button>
                    </div>
                `
            }
        ];
        
        const modal = createPaginatedModal("iOS Audio Setup", pages);
        
        setTimeout(() => {
            const tryAgainBtn = modal.querySelector('#try-mic-again');
            if (tryAgainBtn) {
                tryAgainBtn.addEventListener('click', function() {
                    document.body.removeChild(modal);
                    document.getElementById('micButton').click();
                });
            }
        }, 100);
    }

    // Enhance toggle controls for mobile
    document.getElementById('toggleControls').addEventListener('click', function() {
        const controlPanel = document.getElementById('controlPanel');
        if (controlPanel.style.display === 'none') {
            controlPanel.style.display = 'block';
            this.textContent = '×';
        } else {
            controlPanel.style.display = 'none';
            this.textContent = '≡';
        }
    });

    // Add touch event handling for visualizations
    document.getElementById('visualizer').addEventListener('touchstart', function(e) {
        e.preventDefault(); // Prevent scrolling when touching the canvas
        
        // Toggle controls on canvas touch for mobile
        const controlPanel = document.getElementById('controlPanel');
        if (isMobile) {
            if (controlPanel.style.display === 'none') {
                controlPanel.style.display = 'block';
                document.getElementById('toggleControls').textContent = '×';
            } else {
                controlPanel.style.display = 'none';
                document.getElementById('toggleControls').textContent = '≡';
            }
        }
    });

    // Initialize controls
    initControls();
    initCanvas();
    updateAutoScaleControls();

    // Add new function to draw background effects
    function drawBackgroundEffects(dataArray) {
        // Skip if background effect is set to none
        if (settings.backgroundEffect === 'none') {
            return;
        }
        
        // Calculate average audio level for reactive effects
        let sum = 0;
        const sampleSize = Math.min(64, dataArray.length);
        for (let i = 0; i < sampleSize; i++) {
            sum += dataArray[i];
        }
        const averageLevel = sum / sampleSize / 255;
        
        // Apply different background effects based on settings
        switch(settings.backgroundEffect) {
            case 'gradient':
                drawGradientBackground(averageLevel);
                break;
            case 'stars':
                drawStarfieldBackground(averageLevel);
                break;
            case 'noise':
                drawNoiseBackground(averageLevel);
                break;
            case 'pulse':
                drawPulseBackground(averageLevel);
                break;
        }
    }

    // Gradient background effect
    function drawGradientBackground(audioLevel) {
        // Create gradient
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        
        // Get colors from settings
        const startColor = settings.bgColorStart;
        const endColor = settings.bgColorEnd;
        
        // Add color stops
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        
        // Fill background
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        
        // Add subtle animation based on time
        const time = Date.now() / 5000;
        const noiseScale = 0.01;
        
        // Draw some subtle noise patterns that shift over time
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = '#ffffff';
        
        for (let i = 0; i < 20; i++) {
            const x = Math.sin(time + i * 0.3) * width / 2 + width / 2;
            const y = Math.cos(time + i * 0.2) * height / 2 + height / 2;
            const size = 50 + Math.sin(time + i) * 20;
            
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Starfield background effect
    function drawStarfieldBackground(audioLevel) {
        // Initialize stars array if it doesn't exist
        if (!window.stars) {
            window.stars = [];
            const starCount = 200;
            
            for (let i = 0; i < starCount; i++) {
                window.stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 2 + 0.5
                });
            }
        }
        
        // Fill background with dark color
        ctx.fillStyle = settings.bgColorStart;
        ctx.fillRect(0, 0, width, height);
        
        // Calculate intensity based on settings and audio level
        const baseIntensity = settings.backgroundIntensity / 10;
        const audioReactivity = audioLevel * 2;
        const intensity = baseIntensity + audioReactivity;
        
        // Draw and update stars
        ctx.fillStyle = '#ffffff';
        
        for (let i = 0; i < window.stars.length; i++) {
            const star = window.stars[i];
            
            // Draw star
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size * intensity, 0, Math.PI * 2);
            ctx.fill();
            
            // Move star
            star.x -= star.speed * intensity;
            
            // Reset star if it goes off screen
            if (star.x < 0) {
                star.x = width;
                star.y = Math.random() * height;
            }
        }
    }

    // Noise/static background effect
    function drawNoiseBackground(audioLevel) {
        // Fill background with base color
        ctx.fillStyle = settings.bgColorStart;
        ctx.fillRect(0, 0, width, height);
        
        // Calculate intensity based on settings and audio level
        const baseIntensity = settings.backgroundIntensity / 10;
        const audioReactivity = audioLevel * 2;
        const intensity = baseIntensity + audioReactivity;
        
        // Create noise pattern
        const noiseSize = 4; // Size of noise pixels
        const noiseOpacity = 0.1 * intensity;
        
        ctx.fillStyle = settings.bgColorEnd;
        ctx.globalAlpha = noiseOpacity;
        
        for (let x = 0; x < width; x += noiseSize) {
            for (let y = 0; y < height; y += noiseSize) {
                if (Math.random() > 0.5) {
                    ctx.fillRect(x, y, noiseSize, noiseSize);
                }
            }
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Pulse background effect
    function drawPulseBackground(audioLevel) {
        // Calculate pulse size based on audio level
        const baseIntensity = settings.backgroundIntensity / 10;
        const pulseSize = audioLevel * baseIntensity * 200;
        
        // Create radial gradient for pulse effect
        const gradient = ctx.createRadialGradient(
            width / 2, height / 2, 0,
            width / 2, height / 2, width / 2 + pulseSize
        );
        
        // Add color stops with colors from settings
        gradient.addColorStop(0, settings.bgColorStart);
        gradient.addColorStop(1, settings.bgColorEnd);
        
        // Fill background
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        
        // Add subtle circular waves
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 5; i++) {
            const radius = (Date.now() / 1000 + i * 10) % 100 * 5;
            
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    // Initialize particles for particle effects
    function initParticles() {
        particles = [];
        const count = settings.particleDensity;
        
        for (let i = 0; i < count; i++) {
            particles.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * settings.particleSize + 1,
                speedX: (Math.random() - 0.5) * settings.particleSpeed,
                speedY: (Math.random() - 0.5) * settings.particleSpeed,
                // Add properties for different particle effects
                opacity: Math.random() * 0.5 + 0.5,
                hue: Math.random() * 360
            });
        }
    }

    // Draw and update particles
    function updateParticles(dataArray) {
        if (settings.particleEffect === 'none' || particles.length === 0) {
            return;
        }
        
        // Calculate average audio level for reactive effects
        let sum = 0;
        const sampleSize = Math.min(32, dataArray.length);
        for (let i = 0; i < sampleSize; i++) {
            sum += dataArray[i];
        }
        const averageLevel = sum / sampleSize / 255;
        
        // Apply different particle effects
        switch(settings.particleEffect) {
            case 'dots':
                drawDotParticles(averageLevel);
                break;
            case 'lines':
                drawLineParticles(averageLevel);
                break;
            case 'bubbles':
                drawBubbleParticles(averageLevel);
                break;
            case 'sparkles':
                drawSparkleParticles(averageLevel);
                break;
        }
    }

    // Dot particles effect
    function drawDotParticles(audioLevel) {
        // Set particle color from settings
        ctx.fillStyle = settings.particleColor;
        
        // Calculate audio reactivity
        const reactivity = settings.particleReactToAudio ? audioLevel * 3 : 1;
        
        // Draw and update each particle
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            
            // Draw particle
            ctx.globalAlpha = p.opacity;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * reactivity, 0, Math.PI * 2);
            ctx.fill();
            
            // Update position
            p.x += p.speedX * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            p.y += p.speedY * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            
            // Wrap around screen edges
            if (p.x < 0) p.x = width;
            if (p.x > width) p.x = 0;
            if (p.y < 0) p.y = height;
            if (p.y > height) p.y = 0;
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Line particles effect
    function drawLineParticles(audioLevel) {
        // Set line color and width
        ctx.strokeStyle = settings.particleColor;
        ctx.lineWidth = 1;
        
        // Calculate connection distance based on particle density
        const connectionDist = width / Math.sqrt(particles.length) * 0.8;
        
        // Calculate audio reactivity
        const reactivity = settings.particleReactToAudio ? audioLevel * 3 : 1;
        
        // Update particle positions
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            
            // Update position
            p.x += p.speedX * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            p.y += p.speedY * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            
            // Wrap around screen edges
            if (p.x < 0) p.x = width;
            if (p.x > width) p.x = 0;
            if (p.y < 0) p.y = height;
            if (p.y > height) p.y = 0;
        }
        
        // Draw connections between nearby particles
        for (let i = 0; i < particles.length; i++) {
            const p1 = particles[i];
            
            for (let j = i + 1; j < particles.length; j++) {
                const p2 = particles[j];
                
                // Calculate distance between particles
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Draw line if particles are close enough
                if (distance < connectionDist * reactivity) {
                    // Set opacity based on distance
                    const opacity = 1 - (distance / (connectionDist * reactivity));
                    ctx.globalAlpha = opacity * 0.5;
                    
                    // Draw line
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Bubble particles effect
    function drawBubbleParticles(audioLevel) {
        // Calculate audio reactivity
        const reactivity = settings.particleReactToAudio ? audioLevel * 3 : 1;
        
        // Draw and update each particle
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            
            // Create gradient for bubble
            const gradient = ctx.createRadialGradient(
                p.x, p.y, 0,
                p.x, p.y, p.size * reactivity
            );
            
            // Add color stops
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.5, settings.particleColor);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            // Draw bubble
            ctx.globalAlpha = p.opacity;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 2 * reactivity, 0, Math.PI * 2);
            ctx.fill();
            
            // Update position
            p.x += p.speedX * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            p.y += p.speedY * (settings.particleReactToAudio ? (1 + audioLevel) : 1);
            
            // Wrap around screen edges
            if (p.x < 0) p.x = width;
            if (p.x > width) p.x = 0;
            if (p.y < 0) p.y = height;
            if (p.y > height) p.y = 0;
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Sparkle particles effect
    function drawSparkleParticles(audioLevel) {
        // Calculate audio reactivity
        const reactivity = settings.particleReactToAudio ? audioLevel * 5 : 1;
        
        // Draw and update each particle
        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            
            // Pulsate size based on time
            const time = Date.now() / 1000;
            const pulsate = Math.sin(time * 5 + i) * 0.5 + 0.5;
            const size = p.size * (1 + pulsate * reactivity);
            
            // Set color based on settings or use rainbow effect
            if (settings.particleColor === '#ffffff') {
                // Use rainbow colors if white is selected
                ctx.fillStyle = `hsl(${(p.hue + time * 50) % 360}, 100%, 70%)`;
            } else {
                ctx.fillStyle = settings.particleColor;
            }
            
            // Draw sparkle (star shape)
            ctx.globalAlpha = p.opacity * (0.5 + pulsate * 0.5);
            ctx.beginPath();
            
            // Draw star shape
            for (let j = 0; j < 5; j++) {
                const angle = j * Math.PI * 2 / 5 - Math.PI / 2;
                const outerRadius = size;
                const innerRadius = size * 0.4;
                
                // Outer point
                const outerX = p.x + Math.cos(angle) * outerRadius;
                const outerY = p.y + Math.sin(angle) * outerRadius;
                
                // Inner point
                const innerAngle = angle + Math.PI / 5;
                const innerX = p.x + Math.cos(innerAngle) * innerRadius;
                const innerY = p.y + Math.sin(innerAngle) * innerRadius;
                
                if (j === 0) {
                    ctx.moveTo(outerX, outerY);
                } else {
                    ctx.lineTo(outerX, outerY);
                }
                
                ctx.lineTo(innerX, innerY);
            }
            
            ctx.closePath();
            ctx.fill();
            
            // Update position with slight drift
            p.x += p.speedX * 0.5;
            p.y += p.speedY * 0.5;
            
            // Add some random movement
            p.x += (Math.random() - 0.5) * reactivity;
            p.y += (Math.random() - 0.5) * reactivity;
            
            // Wrap around screen edges
            if (p.x < 0) p.x = width;
            if (p.x > width) p.x = 0;
            if (p.y < 0) p.y = height;
            if (p.y > height) p.y = 0;
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }

    // Add beat detection function
    function detectBeat(dataArray) {
        if (!settings.enableBeatDetection) {
            return false;
        }
        
        // Calculate energy (focus on bass frequencies)
        let energy = 0;
        const bassRange = 10; // Number of low frequency bins to check
        
        for (let i = 0; i < bassRange; i++) {
            energy += dataArray[i] * dataArray[i];
        }
        energy = energy / bassRange;
        
        // Add to history
        beatDetector.energyHistory.unshift(energy);
        
        // Keep history at fixed size
        if (beatDetector.energyHistory.length > beatDetector.historySize) {
            beatDetector.energyHistory.pop();
        }
        
        // Calculate average energy
        let sum = 0;
        for (let i = 0; i < beatDetector.energyHistory.length; i++) {
            sum += beatDetector.energyHistory[i];
        }
        const avgEnergy = sum / beatDetector.energyHistory.length;
        
        // Update beat cutoff
        beatDetector.beatCutoff = beatDetector.beatCutoff * beatDetector.beatCutoffDecay + 
                                 (1 - beatDetector.beatCutoffDecay) * avgEnergy * settings.beatSensitivity;
        
        // Check if we have a beat
        if (energy > beatDetector.beatCutoff && energy > beatDetector.beatMinimum) {
            // Check debounce time
            const now = Date.now();
            if (now - beatDetector.lastBeatTime > beatDetector.debounceTime) {
                beatDetector.lastBeatTime = now;
                beatDetector.isBeat = true;
                return true;
            }
        }
        
        beatDetector.isBeat = false;
        return false;
    }

    // Apply beat effects
    function applyBeatEffects(isBeat) {
        if (!settings.enableBeatDetection || !isBeat) {
            return;
        }
        
        // Apply different effects based on settings
        switch(settings.beatEffect) {
            case 'pulse':
                // Create a flash effect that fades out
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, 0, width, height);
                break;
                
            case 'flash':
                // Create a more intense flash
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(0, 0, width, height);
                break;
                
            case 'zoom':
                // Apply a zoom effect (handled in the visualization loop)
                // This is just a placeholder as the actual effect would require
                // transforming the canvas which is complex to implement here
                break;
                
            case 'shake':
                // Apply a shake effect by moving the canvas slightly
                const intensity = settings.beatEffectIntensity / 2;
                const offsetX = (Math.random() - 0.5) * intensity;
                const offsetY = (Math.random() - 0.5) * intensity;
                
                ctx.translate(offsetX, offsetY);
                setTimeout(() => {
                    ctx.translate(-offsetX, -offsetY);
                }, 50);
                break;
                
            case 'color':
                // Apply a color shift effect
                const hue = (Date.now() / 100) % 360;
                ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.2)`;
                ctx.fillRect(0, 0, width, height);
                break;
        }
    }

    // Reset beat detector
    function resetBeatDetector() {
        beatDetector = {
            energyHistory: [],
            historySize: 43, // About 1 second of history at 60fps
            beatCutoff: 0,
            beatCutoffDecay: 0.98,
            beatMinimum: 0.15,
            lastBeatTime: 0,
            debounceTime: 300, // Minimum time between beats in ms
            isBeat: false
        };
    }

    // Update the visualization function to include new effects
    function visualize() {
        // Get the appropriate buffer length based on the current FFT size
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        // For FPS calculation
        let frameCount = 0;
        let lastFpsUpdateTime = Date.now();

        function draw() {
            requestAnimationFrame(draw);
            
            // Get frequency data
            analyser.getByteFrequencyData(dataArray);
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Detect beat
            const isBeat = detectBeat(dataArray);
            
            // Choose visualization type
            switch(settings.visualizationType) {
                case 'bars':
                    drawBars(dataArray, bufferLength);
                    break;
                case 'wave':
                    drawWave(dataArray, bufferLength);
                    break;
                case 'circular':
                    drawCircular(dataArray, bufferLength);
                    break;
                default:
                    drawBars(dataArray, bufferLength);
            }
            
            // Update and draw particles
            updateParticles(dataArray);
            
            // Apply beat effects
            applyBeatEffects(isBeat);
            
            // Calculate and display FPS if enabled
            if (settings.showFPS) {
                frameCount++;
                
                const now = Date.now();
                const elapsed = now - lastFpsUpdateTime;
                
                if (elapsed >= 1000) {
                    fps = Math.round((frameCount * 1000) / elapsed);
                    frameCount = 0;
                    lastFpsUpdateTime = now;
                }
                
                // Display FPS
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`FPS: ${fps}`, 10, 20);
            }
        }
        
        draw();
    }
    </script>
</body>
</html>